# LED
`led_control.c`
```c
/*
 * Copyright (c) 2006-2021, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2023-05-22     wq0453       the first version
 */

#include <rtdevice.h>
#include "led_control.h"

rt_base_t LED1_PIN_NUM;
rt_base_t LED2_PIN_NUM;
rt_base_t LED3_PIN_NUM;
rt_base_t LED4_PIN_NUM;


void init_io_port(void)
{

    //初始化为输出模式
    LED1_PIN_NUM = rt_pin_get("PE.0");
    LED2_PIN_NUM = rt_pin_get("PE.1");
    LED3_PIN_NUM = rt_pin_get("PE.2");
    LED4_PIN_NUM = rt_pin_get("PE.3");
    rt_pin_mode(LED1_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED2_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED3_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED4_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_write(LED1_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED2_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED3_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED4_PIN_NUM, PIN_HIGH);
}

void control_led(unsigned char cmd)
{
    //根据cmd变量的低四位，控制led输出
    //bit:0 为1， led1 点亮
    if (cmd & 0x01)
        rt_pin_write(LED1_PIN_NUM, PIN_LOW);
    else
        rt_pin_write(LED1_PIN_NUM, PIN_HIGH);

    if (cmd & (0x01<<1))
        rt_pin_write(LED2_PIN_NUM, PIN_LOW);
    else
        rt_pin_write(LED2_PIN_NUM, PIN_HIGH);

    if (cmd & (0x01<<2))
        rt_pin_write(LED3_PIN_NUM, PIN_LOW);
    else
        rt_pin_write(LED3_PIN_NUM, PIN_HIGH);

    if (cmd & (0x01<<3))
        rt_pin_write(LED4_PIN_NUM, PIN_LOW);
    else
        rt_pin_write(LED4_PIN_NUM, PIN_HIGH);

}

void turn(int a) {
    if(a == 1) {
        rt_pin_write(LED1_PIN_NUM, PIN_LOW);
        rt_pin_write(LED2_PIN_NUM, PIN_LOW);
        rt_pin_write(LED3_PIN_NUM, PIN_LOW);
        rt_pin_write(LED4_PIN_NUM, PIN_LOW);

    }
    else {
        rt_pin_write(LED1_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED2_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED3_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED4_PIN_NUM, PIN_HIGH);
    }
}
void loop_led(void)
{
    static unsigned char var = 0x01;

    control_led(var);

    var = (var<<1);
    if(var == 0x10)
        var = 0x01;

    rt_thread_delay(500);
}

```

`led_control.h`
```c
/*
 * Copyright (c) 2006-2021, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2023-05-22     wq0453       the first version
 */
#ifndef APPLICATIONS_LED_CONTROL_H_
#define APPLICATIONS_LED_CONTROL_H_


void loop_led(void);
void init_io_port(void);
void control_led(unsigned char cmd);
void loop_led(void);


#endif /* APPLICATIONS_LED_CONTROL_H_ */

```
# 多线程

**例程**

```c
#include <rtthread.h>
#include <rtdevice.h>
#define THREAD_PRIORITY 25
#define THREAD_STACK_SIZE 512
#define THREAD_TIMESLICE 5
#define DBG_TAG "main"
#define DBG_LVL DBG_LOG

#include <rtdbg.h>
static rt_thread_t tid1,tid2 = RT_NULL;
rt_base_t LED1_PIN_NUM;
rt_base_t LED2_PIN_NUM;
rt_base_t LED3_PIN_NUM;
rt_base_t LED4_PIN_NUM;
static void thread1_entry(void *parameter)
{
    rt_uint32_t count = 0;
    while(1){
        rt_kprintf("thread1 count: %d\n", count ++);

        rt_thread_mdelay(600);
        rt_pin_write(LED1_PIN_NUM, PIN_LOW);
        rt_pin_write(LED2_PIN_NUM, PIN_LOW);

        rt_thread_mdelay(600);
        rt_pin_write(LED1_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED2_PIN_NUM, PIN_HIGH);
    }
}

static void thread2_entry(void *parameter)
{
    rt_uint32_t count = 0;
    while(1){
        rt_kprintf("thread2 count: %d\n", count ++);

        rt_thread_mdelay(300);

        rt_pin_write(LED3_PIN_NUM, PIN_LOW);
        rt_pin_write(LED4_PIN_NUM, PIN_LOW);

        rt_thread_mdelay(300);
        rt_pin_write(LED3_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED4_PIN_NUM, PIN_HIGH);
    }
}

void init_io_port(){
    LED1_PIN_NUM = rt_pin_get("PE.0");
    LED2_PIN_NUM = rt_pin_get("PE.1");
    LED3_PIN_NUM = rt_pin_get("PE.2");
    LED4_PIN_NUM = rt_pin_get("PE.3");
    rt_pin_write(LED1_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED2_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED3_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED4_PIN_NUM, PIN_HIGH);
    rt_pin_mode(LED1_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED2_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED3_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED4_PIN_NUM, PIN_MODE_OUTPUT);
}

int main()
{

    init_io_port();

    tid1 = rt_thread_create("thread1",
            thread1_entry,RT_NULL,
            THREAD_STACK_SIZE,
            THREAD_PRIORITY,THREAD_TIMESLICE);

    if(tid1 != RT_NULL)
        rt_thread_startup(tid1);

    tid2 = rt_thread_create("thread2",
            thread2_entry,RT_NULL,
            THREAD_STACK_SIZE,
            THREAD_PRIORITY,THREAD_TIMESLICE);

    if(tid2 != RT_NULL)
        rt_thread_startup(tid2);


    return RT_EOK;

}

```


# 拍手灯-计时器
```c
#include <rtthread.h>
#include <rtdevice.h>

#define DBG_TAG "main"
#define DBG_LVL DBG_LOG

#include <rtdbg.h>

// LED状态枚举类型
enum LedStatus {
    LED_IDLE, // 空闲状态
    LED_CLAP  // 拍手状态
};

volatile enum LedStatus curr_state = LED_IDLE; // 当前LED状态

// 定义LED引脚号
rt_base_t LED1_PIN_NUM;
rt_base_t LED2_PIN_NUM;
rt_base_t LED3_PIN_NUM;
rt_base_t LED4_PIN_NUM;

int cnt = 0; // 拍手计数
volatile unsigned int flag_sound_first_pulse = 1; // 第一次声音脉冲标志

volatile unsigned int flag_led_status = 0x0; // LED状态标志
volatile unsigned int flag_clap_timer = 0; // 拍手计时器标志
volatile unsigned int flag_clap_timer_timeout = 0; // 拍手计时器超时标志

rt_uint32_t status;

// 定义两个定时器
rt_timer_t clap_space_timer = RT_NULL;
rt_timer_t debounce_timer = RT_NULL;

// 消抖定时器回调函数
void on_debounce_timer(void *parameter) {
    rt_kprintf(">>>Debouned cnt = %d\n", cnt);
    flag_sound_first_pulse = 1;
}

// 拍手间隔定时器回调函数
void on_clap_space_timer(void *parameter) {
    flag_clap_timer = 1;
    rt_kprintf(">>> 1s clap_timer_timeout\n");

    if (cnt == 2) { // 判断是否为两次拍手
        curr_state = LED_IDLE;

        // 切换LED状态
        if (flag_led_status) {
            flag_led_status = 0x0;
            control_led(0xf);
            rt_kprintf("shift\n");
        } else {
            flag_led_status = 0xf;
            control_led(0x0);
            rt_kprintf("shift\n");
        }

        rt_kprintf(">>>>>>>  CLAP -> IDLE\n");
    } else {
        curr_state = LED_IDLE;
        rt_kprintf("CLAP -> IDLE\n");
    }

    cnt = 0; // 重置拍手计数
}

// 初始化定时器
void timer_init(void) {
    clap_space_timer = rt_timer_create("clap_space_timer", // 定时器名称
                                       on_clap_space_timer, // 定时器回调函数
                                       RT_NULL, // 回调函数参数
                                       1000, // 定时器超时时间（单位：ms）
                                       RT_TIMER_FLAG_ONE_SHOT); // 单次定时器

    debounce_timer = rt_timer_create("debounce_timer", // 定时器名称
                                     on_debounce_timer, // 定时器回调函数
                                     RT_NULL, // 回调函数参数
                                     250, // 定时器超时时间（单位：ms）
                                     RT_TIMER_FLAG_ONE_SHOT); // 单次定时器
}

// 声音检测中断回调函数
void on_soundlevel(void *para) {
    rt_timer_start(debounce_timer); // 启动消抖定时器

    if (flag_sound_first_pulse) {
        cnt++;
        flag_sound_first_pulse = 0;
        rt_kprintf("on_soundlevel\n");

        if (curr_state == LED_IDLE) {
            curr_state = LED_CLAP;
            rt_timer_start(clap_space_timer); // 启动拍手间隔定时器
            rt_kprintf(">>>>>>>   IDLE -> CLAP\n");
        } else {
            rt_timer_stop(clap_space_timer); // 停止定时器
            rt_timer_start(clap_space_timer); // 重新启动定时器
        }
    }
}

// 初始化IO端口
void init_io_port(void) {
    // 获取并设置引脚为输出模式
    LED1_PIN_NUM = rt_pin_get("PE.0");
    LED2_PIN_NUM = rt_pin_get("PE.1");
    LED3_PIN_NUM = rt_pin_get("PE.2");
    LED4_PIN_NUM = rt_pin_get("PE.3");

    rt_pin_write(LED1_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED2_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED3_PIN_NUM, PIN_HIGH);
    rt_pin_write(LED4_PIN_NUM, PIN_HIGH);

    rt_pin_mode(LED1_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED2_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED3_PIN_NUM, PIN_MODE_OUTPUT);
    rt_pin_mode(LED4_PIN_NUM, PIN_MODE_OUTPUT);
}

// 控制LED灯的函数
void control_led(volatile unsigned int x) {
    // 根据x的低四位控制LED输出
    if (x == 0xf) {
        rt_pin_write(LED1_PIN_NUM, PIN_LOW);
        rt_pin_write(LED2_PIN_NUM, PIN_LOW);
        rt_pin_write(LED3_PIN_NUM, PIN_LOW);
        rt_pin_write(LED4_PIN_NUM, PIN_LOW);
    } else {
        rt_pin_write(LED1_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED2_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED3_PIN_NUM, PIN_HIGH);
        rt_pin_write(LED4_PIN_NUM, PIN_HIGH);
    }
}

// 初始化中断
void init_int(void) {
    rt_pin_attach_irq(rt_pin_get("PC.0"), PIN_IRQ_MODE_FALLING, on_soundlevel, RT_NULL); // 附加中断回调函数
    rt_pin_irq_enable(rt_pin_get("PC.0"), PIN_IRQ_ENABLE); // 启用引脚中断
}

// 主函数
int main(void) {
    init_io_port(); // 初始化IO端口
    init_int(); // 初始化中断
    timer_init(); // 初始化定时器

    while (1) {
        rt_thread_delay(10); // 延时
    }

    return RT_EOK;
}

```

# MQTT消息处理

```c
// MQTT消息处理函数

static void sub_topic_handle1(void *client, message_data_t *msg) {

    (void) client;

    KAWAII_MQTT_LOG_I("-----------------------------------------------------------------------------------");

    KAWAII_MQTT_LOG_I("%s:%d %s()...\ntopic: %s\nmessage:%s", __FILE__, __LINE__, __FUNCTION__, msg->topic_name,

                      (char *) msg->message->payload);

    KAWAII_MQTT_LOG_I("-----------------------------------------------------------------------------------");

  

    /* 解析接收到的JSON消息 */

    cJSON *json = cJSON_Parse(msg->message->payload);

    if (json == NULL) {

        KAWAII_MQTT_LOG_E("Failed to parse JSON message");

        return;

    }

  

    /* 处理 "loop" 字段 */

    cJSON *loop_item = cJSON_GetObjectItem(json, "loop");

    if (cJSON_IsString(loop_item) && (strcmp(loop_item->valuestring, "turnon") == 0)) {

        rt_kprintf("Received turnon command for loop\n");

        if (tid1 == RT_NULL) {

            // 创建并启动线程1

            tid1 = rt_thread_create("led_thread", led_thread_entry, RT_NULL, 2048, 25, 10); // 增加堆栈大小

            if (tid1 != RT_NULL) {

                rt_thread_startup(tid1);

            }

        }

    } else if (cJSON_IsString(loop_item) && (strcmp(loop_item->valuestring, "turnoff") == 0)) {

        rt_kprintf("Received turnoff command for loop\n");

        if (tid1 != RT_NULL) {

            // 挂起并删除线程1

            rt_thread_delete(tid1);

            tid1 = RT_NULL;

        }

    }

  

    /* 处理 "light" 字段 */

    cJSON *light_item = cJSON_GetObjectItem(json, "light");

    if (cJSON_IsString(light_item) && (strcmp(light_item->valuestring, "start") == 0)) {

        rt_kprintf("Received start command for light\n");

        rt_kprintf("yes\n");

    } else if (cJSON_IsString(light_item) && (strcmp(light_item->valuestring, "stop") == 0)) {

        rt_kprintf("Received stop command for light\n");

    }

  

    /* 释放JSON对象 */

    cJSON_Delete(json);

}
```

